<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="Stylesheet" type="text/css" href="../../style.css" />
        <title>2015-05-14</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    </head>
    <body>
        <header>
            <nav>
                <p>
                    <a href="../../index.html">Home</a>
                    <a href="../../projects.html">Projects</a>
                    <a href="../../diary/index.html">Blog</a>
                </p>
            </nav>
        </header>

        <main>
            
<p>
---
tags: docker microservices python
title: Building a componentised application
---
</p>

<p>
Most of what's here is hardly new ground but I felt it worth noting down the current strategy we're using to develop and build what we're working on at [Proxama](<a href="http://www.locationsciences.ai/).">http://www.locationsciences.ai/).</a>
</p>

<p>
Without going into any of the details, it's a web application with a front end written using [Ember](<a href="http://emberjs.com/)">http://emberjs.com/)</a> and various services that it calls out to, written using whatever seems appropriate per service.
</p>

<p>
At the outset of the project, we decided we would bite the bullet and build for [Docker](<a href="https://www.docker.com/)">https://www.docker.com/)</a> from the outset. This meant we would get to avoid the usual dependency and developer environment setup nightmares.
</p>

<p>
## The problem
</p>

<p>
What we quickly realised as we started to put the bare bones of a few of the services in place, was that we had three seemingly conflicting goals for each component and for the application as a whole.
</p>

<ol>
<li>
Build images that can be deployed in production.

<li>
Allow developers to run services locally.

<li>
Provide a means for running unit tests (both by developers and our CI server).

</ol>
<p>
So here's what we've ended up with:
</p>

<p>
## The solution
</p>

<p>
*Or: [docker-compose](<a href="http://docs.docker.com/compose/)">http://docs.docker.com/compose/)</a> to the rescue*
</p>

<p>
### Folder structure
</p>

<p>
Here's what the project layout looks like:
</p>

<p>
```console 
Project
|
+-docker-compose.yml
|
+-Service 1
<table>
<tr>
<td>
&nbsp;
</td>
</tr>
</table>
| +-Dockerfile
<table>
<tr>
<td>
&nbsp;
</td>
</tr>
</table>
| +-docker.compose.yml
<table>
<tr>
<td>
&nbsp;
</td>
</tr>
</table>
| +-&lt;other files&gt;
|
+-Service 2
  |
  |
  +-Dockerfile
  |
  +-docker.compose.yml
  |
  +-&lt;other files&gt;
```
</p>

<p>
### Building for production
</p>

<p>
This is the easy bit and is where we started first. The <code>Dockerfile</code> for each service was designed to run everything with the defaults. Usually, this is something simple like:
</p>

<p>
```dockerfile 
FROM python:3-onbuild
CMD ["python", "main.py"]
```
</p>

<p>
Our CI server can easily take these, produce images, and push them to the registry.
</p>

<p>
### Allowing developers to run services locally
</p>

<p>
This is slightly harder. In general, each service wants to do something slightly different when being run for development; e.g. automatically restarting when code changes. Additionally, we don't want to have to rebuild an image every time we make a code change. This is where <code>docker-compose</code> comes in handy.
</p>

<p>
The <code>docker-compose.yml</code> at the root of the project folder looks like this:
</p>

<p>
```yaml 
service1:
</p>
<pre><code>build: Service 1
environment:
ENV: dev
volumes:
</pre></code>
<ul>
<li>
Service 1:/usr/src/app
    links:

<li>
service2

<li>
db
    ports:

<li>
8001:8000

</ul>
<p>
service2:
</p>
<pre><code>build: Service2
environment:
ENV: dev
volumes:
</pre></code>
<ul>
<li>
Service 2:/usr/src/app
    links:

<li>
service1

<li>
db
    ports:

<li>
8002:8000

</ul>
<p>
db:
</p>
<pre><code>image: mongo
</code></pre>
<p>
```
</p>

<p>
This gives us several features right away:
</p>

<ul>
<li>
We can locally run all of the services together with <code>docker-compose up</code>

<li>
The <code>ENV</code> environment variable is set to <code>dev</code> in each service so that the service can configure itself when it starts to run things in "dev" mode where needed.

<li>
The source folder for each service is mounted inside the container. This means you don't need to rebuild the image to try out new code.

<li>
Each service is bound to a different port so you can connect to each part directly where needed.

<li>
Each service defines links to the other services it needs.

</ul>
<p>
### Running the tests
</p>

<p>
This was the trickiest part to get right. Some services have dependencies on other things even just to get unit tests running. For example, [Eve](<a href="http://python-eve.org/)">http://python-eve.org/)</a> is a huge pain to get running with a fake database so it's much easier to just link it to a temporary "real" database.
</p>

<p>
Additionally, we didn't want to mess with the idea that the images should run production services by default but also didn't want to require folks to need to churn out complicated <code>docker</code> invocations like <code>docker run --rm -v $(pwd):/usr/src/app --link db:db service1 python -m unittest</code> just to run the test suite after coding up some new features.
</p>

<p>
So, it was docker-compose to the rescue again :)
</p>

<p>
Each service has a <code>docker-compose.yml</code> that looks something like:
</p>

<p>
```yaml 
tests:
</p>
<pre><code>build: .
command: python -m unittest
volumes:
</pre></code>
<ul>
<li>
.:/usr/src/app
    links:

<li>
db

</ul>
<p>
db:
</p>
<pre><code>image: mongo
</code></pre>
<p>
```
</p>

<p>
Which sets up any dependencies needed just for the tests, mounts the local source in the container, and runs the desired command for running the tests.
</p>

<p>
So, a developer (or the CI box) can run the unit tests with:
</p>

<p>
```shell 
docker-compose run tests
```
</p>

<p>
## Summary
</p>

<ul>
<li>
Each <code>Dockerfile</code> builds an image that can go straight into production without further configuration required.

<li>
Each image runs in "developer mode" if the <code>ENV</code> environment variable is set.

<li>
Running <code>docker-compose up</code> from the root of the project gets you a full stack running locally in developer mode.

<li>
Running <code>docker-compose run tests</code> in each service's own folder will run the unit tests for that service - starting any dependencies as needed.

</ul>

        </main>

        <footer>
            <p>
            All content Â© 2011-2024 Steve Engledow.
            <br />
            All views expressed here are mine and don't reflect those of Amazon.
            <br />
            The <a href="https://github.com/stilvoid/stilvoid.github.io">contents of this web site</a> are available under the terms of the <a href="https://github.com/stilvoid/stilvoid.github.io/blob/master/LICENSE">MIT licence</a>.
            </p>
        </footer>
    </body>
</html>
